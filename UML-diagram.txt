@startuml Connect4
namespace Connect4 {

  class Connect4{
    - board : model.Board
    - turn: model.Turn
    + Connect4()
    + play()
    + readMove(Scanner): int
    + {static} main(String[])
  }

  class model.Board {
    - tokens: model.Token[][]
    - solution: Solution
    ~ model.Board()
    ~ dropPiece(column, token): boolean
    ~ enableColumn(column): boolean
    ~ checkVictory(model.Token): boolean
    ~ print()
    ~ isBoardFull(): boolean
    ~ getColorOnPosition(row, column): model.Token
    ~ isTokenNone(row, column): model.Token
  }

  class model.Turn {
    - NUM_PLAYERS
    - value: Int
    - players: model.Player[]
    ~ model.Turn(model.Board)
    ~ player(): model.Player
    ~ playerColor(): model.Token
    ~ previousPlayer(): model.Player
    ~ previousPlayerColor(): model.Token
    ~ alternateValue(): int
    ~ changeValue()
  }

  class model.Player {
    - color: model.Token
    ~ model.Player(model.Token)
    ~ put(model.Board, columna)
    ~ getColor(): model.Token
    ~ askForColumn()
  }

  class Coordinate {
    - rowPosition
    - columnPosition
  }

  class Line {
    - line: Coordinate[model.Board.LINE_SIZE]
    -

  }


  enum model.Token {
    XS
    OS
    NONE
    ~ model.Token(value)
    ~ getToken()
  }

  enum model.Error {
    OUT_OF_RANGE
    COLUMN_FULL
    ~ writeLn()
  }

  enum Message {
    TURN
    DRAWS
    WIN
    DROP_TOKEN
    ~ writeLn()
  }

  class Solution {
    ~ vertical(model.Board)
    ~ horizontal(model.Board)
    ~ ascendentDiagonal(model.Board)
    ~ descendentDiagonal(model.Board)
  }

  Connect4 *-down-> model.Board
  Connect4 *-down-> model.Turn
  Connect4 .-down-> Message
  model.Player *-down-> model.Board
  model.Turn *-down-> "2" model.Player
  model.Player *-down-> model.Token
  model.Board *-down->Solution
  model.Board .down->model.Token
  model.Board .down->model.Error
  model.Board .down->Line
  model.Board .down->Coordinate
  Line *-down->Coordinate
}

@enduml
